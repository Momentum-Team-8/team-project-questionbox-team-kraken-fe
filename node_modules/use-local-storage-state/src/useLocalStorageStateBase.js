"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const storage_1 = require("./storage");
const react_1 = require("react");
function useLocalStorageStateBase(key, defaultValue) {
    const defaultValueForKey = react_1.useMemo(() => {
        const isCallable = (value) => typeof value === 'function';
        return isCallable(defaultValue) ? defaultValue() : defaultValue;
        // disabling "exhaustive-deps" on purpose. we don't want to change the default state when
        // the `defaultValue` is changed.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [key]);
    const defaultState = react_1.useMemo(() => {
        return {
            value: storage_1.default.get(key, defaultValueForKey),
            isPersistent: (() => {
                /**
                 * We want to return `true` on the server. If you render a message based on
                 * `isPersistent` and the server returns `false` then the message will flicker until
                 * hydration is done:
                 * `{!isPersistent && <span>You changes aren't being persisted.</span>}`
                 */
                if (typeof window === 'undefined') {
                    return true;
                }
                try {
                    // ulss = use-local-storage-state
                    // using shorthand to make library smaller in size
                    localStorage.setItem('__ulss', '#');
                    localStorage.removeItem('__ulss');
                    return true;
                }
                catch (_a) {
                    return false;
                }
            })(),
        };
    }, [key, defaultValueForKey]);
    const [state, setState] = react_1.useState(defaultState);
    const updateValue = react_1.useMemo(() => {
        const fn = (newValue) => {
            const isCallable = (value) => typeof value === 'function';
            if (isCallable(newValue)) {
                setState((state) => ({
                    value: newValue(state.value),
                    isPersistent: storage_1.default.set(key, newValue(state.value)),
                }));
            }
            else {
                setState({
                    value: newValue,
                    isPersistent: storage_1.default.set(key, newValue),
                });
            }
        };
        fn.reset = () => {
            storage_1.default.remove(key);
            setState((state) => ({
                value: defaultValueForKey,
                isPersistent: state.isPersistent,
            }));
        };
        return fn;
    }, [key, defaultValueForKey]);
    // syncs changes across tabs and iframe's
    react_1.useEffect(() => {
        const onStorage = (e) => {
            if (e.storageArea === localStorage && e.key === key) {
                setState({
                    value: storage_1.default.get(key, defaultValueForKey),
                    isPersistent: true,
                });
            }
        };
        window.addEventListener('storage', onStorage);
        return () => window.removeEventListener('storage', onStorage);
    }, [key, defaultValueForKey]);
    const isFirstRender = react_1.useRef(true);
    react_1.useEffect(() => {
        // set the `defaultValue` in the localStorage on initial render:
        // https://github.com/astoilkov/use-local-storage-state/issues/26
        storage_1.default.set(key, defaultState.value);
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        // update the state when the `key` property changes (not on first render because this will
        // cause a second unnecessary render)
        setState(defaultState);
    }, [key, defaultState]);
    return [state.value, updateValue, state.isPersistent];
}
exports.default = useLocalStorageStateBase;
